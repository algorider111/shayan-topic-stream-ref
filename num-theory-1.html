<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Number Theory #1: GCD, Euclidean Algorithm, Prime</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #fdfdfd;
      color: #222;
      line-height: 1.7;
    }
    header {
      background-color: #1f1f1f;
      color: #fff;
      padding: 1rem 2rem;
      text-align: center;
    }
    nav {
      background: #272727;
      padding: 0.5rem 2rem;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    nav a {
      color: #ddd;
      text-decoration: none;
      margin-right: 1rem;
    }
    nav a:hover {
      color: #fff;
    }
    main {
      max-width: 960px;
      margin: auto;
      padding: 2rem 1rem;
    }
    h1, h2, h3 {
      color: #1a1a1a;
    }
    code {
      color : white;
      padding: 2px 5px;
      border-radius: 3px;
    }
    pre {
      background: #272727;
      color: #e0e0e0;
      padding: 1rem;
      border-radius: 5px;
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.5rem;
      text-align: left;
    }
    th {
      background: #f4f4f4;
    }
    footer {
      text-align: center;
      padding: 2rem;
      background: #f1f1f1;
      margin-top: 4rem;
    }
    @media screen and (max-width: 600px) {
      nav {
        flex-direction: column;
      }
      nav a {
        margin: 0.5rem 0;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Number Theory Lecture 1</h1>
    <p>GCD, Euclidean Algorithm, and Prime Numbers</p>
  </header>
  <nav>
    <a href="index.html">üè† Home</a>
    <a href="#gcd">GCD</a>
    <a href="#euclidean">Euclidean</a>
    <a href="#prime">Prime</a>
    <a href="#sieve">Sieve</a>
  </nav>
  <main>
    <section>
      <h2>Overview</h2>
      <p>Number theory is the mathematical study of integers and their properties. This lecture introduces foundational concepts that form the basis for more advanced number theory and competitive programming techniques. You'll explore what the GCD is, how to compute it using the Euclidean Algorithm, the nature of prime numbers, and efficient methods to determine primality, including the Sieve of Eratosthenes.</p>
    </section>

    <section id="gcd">
      <h2>Part 1: Greatest Common Divisor (GCD)</h2>
      <p>The <strong>Greatest Common Divisor (GCD)</strong> of two or more integers is the largest integer that divides all of them without leaving any remainder. If two numbers have GCD = 1, they are called <em>co-prime</em>.</p>
      <h3>Example</h3>
      <p><strong>gcd(24, 16)</strong>:</p>
      <ul>
        <li>Divisors of 24: 1, 2, 3, 4, 6, 8, 12, 24</li>
        <li>Divisors of 16: 1, 2, 4, 8, 16</li>
        <li>Common divisors: 1, 2, 4, 8</li>
        <li><strong>Result:</strong> GCD = 8</li>
      </ul>

      <h3>Key Properties of GCD</h3>
      <ul>
        <li><code>gcd(a, b) = gcd(b, a % b)</code></li>
        <li><code>gcd(x, 0) = x</code></li>
        <li><code>gcd(a, b) = gcd(a - b, b)</code> (basic recursive idea)</li>
      </ul>

      <h3>Mathematical Proof</h3>
      <p>Assume <code>a = d¬∑x</code> and <code>b = d¬∑y</code>, then:</p>
      <p><code>a - b = d¬∑(x - y)</code>, so <code>d</code> divides <code>a - b</code> as well.</p>
    </section>

    <section id="euclidean">
      <h2>Part 2: Euclidean Algorithm</h2>
      <p>The Euclidean Algorithm is an efficient method for computing the GCD of two numbers based on the principle:</p>
      <p><code>gcd(a, b) = gcd(b, a % b)</code></p>
      <p>This recursive reduction continues until one value becomes zero.</p>

      <h3>Time Complexity</h3>
      <p>Each step reduces the size of the inputs significantly. The algorithm runs in <strong>O(log min(a, b))</strong>.</p>

      <h3>Code Example</h3>
      <pre><code>int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}</code></pre>

      <h3>Real-World Application Problem</h3>
      <p>Given two arrays <code>A[1..n]</code> and <code>B[1..m]</code>, for each <code>B[j]</code> compute:</p>
      <p><code>gcd(A[1] + B[j], A[2] + B[j], ..., A[n] + B[j])</code></p>

      <p><strong>Optimized Solution:</strong></p>
      <ul>
        <li>Let <code>d = gcd(|A[2] - A[1]|, ..., |A[n] - A[1]|)</code></li>
        <li>Then answer is <code>gcd(A[1] + B[j], d)</code> for each <code>B[j]</code></li>
      </ul>

      <pre><code>ll computeGCD(const vector<ll>& a) {
  ll d = 0;
  for (int i = 1; i < a.size(); ++i)
    d = gcd(d, abs(a[i] - a[0]));
  return d;
}

vector<ll> solve(const vector<ll>& a, const vector<ll>& b) {
  ll baseGCD = computeGCD(a);
  vector<ll> result;
  for (ll bj : b)
    result.push_back(gcd(a[0] + bj, baseGCD));
  return result;
}</code></pre>
    </section>

    <section id="prime">
      <h2>Part 3: Prime Numbers</h2>
      <p>A <strong>prime number</strong> is a number greater than 1 that is divisible only by 1 and itself.</p>

      <h3>Examples:</h3>
      <ul>
        <li>Prime: 2, 3, 5, 7, 11</li>
        <li>Not Prime: 4 (2√ó2), 6 (2√ó3), 9 (3√ó3)</li>
      </ul>

      <h3>Naive Primality Test</h3>
      <pre><code>bool isPrime(int n) {
  if (n < 2) return false;
  for (int i = 2; i < n; ++i)
    if (n % i == 0) return false;
  return true;
}</code></pre>
      <p>Time: O(n)</p>

      <h3>Optimized Primality Test</h3>
      <pre><code>bool isPrime(int n) {
  if (n < 2) return false;
  for (int i = 2; i * i <= n; ++i)
    if (n % i == 0) return false;
  return true;
}</code></pre>
      <p>Time: O(&radic;n)</p>
    </section>

    <section id="sieve">
      <h2>Part 4: Sieve of Eratosthenes</h2>
      <p>The <strong>Sieve of Eratosthenes</strong> is a powerful method to find all primes from 1 to n.</p>

      <pre><code>vector<bool> sieve(int n) {
  vector<bool> isPrime(n+1, true);
  isPrime[0] = isPrime[1] = false;
  for (int i = 2; i * i <= n; ++i) {
    if (isPrime[i]) {
      for (int j = i * i; j <= n; j += i)
        isPrime[j] = false;
    }
  }
  return isPrime;
}</code></pre>

      <h3>Why Start from i * i?</h3>
      <p>Any composite number less than <code>i * i</code> would have already been marked by smaller prime factors.</p>

      <p><strong>Time Complexity:</strong> O(n log log n)</p>
    </section>

    <section>
      <h2>Summary Table</h2>
      <table>
        <tr><th>Concept</th><th>Description</th></tr>
        <tr><td>GCD</td><td>Largest number dividing all input integers</td></tr>
        <tr><td>Euclidean Algorithm</td><td>Efficient way using gcd(b, a % b)</td></tr>
        <tr><td>Time of GCD</td><td>O(log min(a, b))</td></tr>
        <tr><td>Prime Number</td><td>Only divisible by 1 and itself</td></tr>
        <tr><td>Primality Test</td><td>Check if number is prime (O(sqrt(n)))</td></tr>
        <tr><td>Sieve of Eratosthenes</td><td>Efficient method to generate primes</td></tr>
      </table>
    </section>
  </main>
  <footer>
    <p>End of Lecture 1 | Next Lecture: T-Primes and Factorization</p>
  </footer>
</body>
</html>
